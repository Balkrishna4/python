# -*- coding: utf-8 -*-
"""Functions-2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LnaaaqwMw0Y5ecviRamvdq5OoRoN77n_

## Pass By Reference & Pass By Value.

Python's argument passing model has often been a cause of confusion among developers, particularly those coming from languages like C++ and Java.

"Pass by value" and "pass by reference" are two common ways that programming languages handle the passing of arguments (variables or values) to functions or methods. These two approaches define how changes made to the argument inside the function affect the original variable outside the function.

### Pass by Value:

In "pass by value," a copy of the actual value of the argument is passed to the function. Changes made to the parameter inside the function do not affect the original argument outside the function. This approach is commonly associated with languages like C and C++.

### Pass by Reference:

In "pass by reference," a reference (memory address or a pointer) to the original argument is passed to the function. Changes made to the parameter inside the function directly affect the original argument outside the function. This approach is commonly associated with languages like C++ (with reference types), Perl, and some scripting languages.

## Python uses a combination of pass-by-value and pass-by-reference depending on the object type:

**Pass by Value:** Immutable objects, such as numbers (integers, floats), strings, and tuples, are passed by value. A copy of the object's value is created and assigned to a new local variable within the function. Changes made to the local variable do not affect the original object outside the function.
"""

num = 5

def modify_number(num):
    num += 1
    print("Inside function:", num)

modify_number(num)

print("Outside function:", num)

# Output:
# Inside function: 6
# Outside function: 5

"""**Pass by Reference**: Mutable objects, such as lists, dictionaries, and custom objects, are passed by reference. The reference to the object is passed, not a copy of the object itself. Changes made to the mutable object inside the function affect the original object outside the function."""

my_list = [1, 2, 3]


def modify_list(lst):
    lst.append(4)
    print("Inside function:", lst)

modify_list(my_list)
print("Outside function:", my_list)

# Output
# Inside function: [1, 2, 3, 4]
# Outside function: [1, 2, 3, 4]

"""## Lambda or Anonymous functions.

Lambda functions are essentially unnamed and temporary functions that can be used for any operation requiring less than a few lines of code. They are particularly useful for situations where you want to quickly execute a function and then discard it immediately, without needing to save it for later use.

Lambda functions in Python are also called anonymous functions. They are a perfect solution to writing functions right where they are used instead of separately defining them. Lambda functions are created using the lambda keyword, followed by one or many parameters and an expression. You can use lambda functions to write short and simple code that can be executed once and doesn't need to be named.

"""

add = lambda x, y: x + y
result = add(3, 5)
print(result)  # Output: 8

"""## Built-in functions.

Python provides a wide range of built-in functions that are readily available for use without requiring any additional code or imports.

Here are some commonly used built-in functions in Python:

- print(): Prints output to the console.
- input(): Reads input from the user via the console.
- len(): Returns the length of an object, such as a string, list, or tuple.
- type(): Returns the type of an object.
- range(): Generates a sequence of numbers.
- int(), float(), str(), bool(): Converts a value to an integer, float, string, or boolean, respectively.
- max(), min(): Returns the maximum or minimum value from a sequence or a set of arguments.
- abs(): Returns the absolute value of a number.
- sum(): Returns the sum of all elements in a sequence.
- round(): Rounds a number to a specified number of decimal places.
- sorted(): Returns a sorted version of a sequence or an iterable.
- enumerate(): Returns an iterator of tuples containing index-value pairs.
- zip(): Combines multiple iterables into a single iterable of tuples.
- map(): Applies a function to each item in an iterable and returns an iterator of the results.
- filter(): Filters elements from an iterable based on a given function.
- any(), all(): Checks if any or all elements in an iterable are True.
- open(): Opens a file for reading or writing.
- eval(): Evaluates a string as a Python expression.
- str.format(): Formats a string by substituting placeholders with values.
- dir(): Returns a list of names in the current namespace or of an object's attributes.

These built-in functions save you time and make your code simpler because you don't have to reinvent the wheel every time you want to do something common in your programs.

## Exception Handling.

Python exceptions are those unexpected errors that can occur during the execution of a program. They can be quite frustrating but, we have the powerful try and except statements to safeguard our code. When an exception is encountered, the program doesn't come crashing down, instead, it gracefully handles the exception and continues its execution.

With the try and except statements, we can enclose the risky lines of code that might raise exceptions within the try block. If an exception occurs, instead of abruptly terminating the program, the flow of execution is diverted to the except block, which handles the exception and carries on. The try-except statement can also be accompanied by an else clause, which is executed if no exceptions are raised. To ensure that certain code always gets executed, regardless of whether an exception occurs or not, we have the finally clause.
"""

x = 5
y=0
result = x/y
print(result)

try :
  x = 5
  y=1
  print("Mere dost")
  result = x/y
  print(result)
except :
  print("Some error happened")

#Catching the exception type
import sys
try :
  x = 5
  y=0
  result = x/y
  print("Exception ke baad ki dosti")
  print(result)
except :
  exc_type, exc_value, exc_traceback = sys.exc_info()
  print("Some error happened" , exc_type)
  print(exc_value)
  print(exc_traceback)

#If exception doesn't happen
#Catching the exception type
import sys
try :
  x = 5
  y=1
  result = x/y
  print(result)
except :
  exc_type, exc_value, exc_traceback = sys.exc_info()
  print("Some error happened" , exc_type)

#We can use else as well
import sys
try :
  x = 5
  y=1
  result = x/y

except :
  exc_type, exc_value, exc_traceback = sys.exc_info()
  print("Some error happened" , exc_type)
else :
  print(result)

#We can use else as well
import sys
try :
  x = 5
  y=1
  result = x/y

except :
  exc_type, exc_value, exc_traceback = sys.exc_info()
  print("Some error happened" , exc_type)
else :
  print(result)
finally :
  print("I will be always executed")

try:
    x = int(input("Enter a number: "))
    result = 10 / x
except ValueError:
    print("Invalid input. Please enter a valid number.")
except ZeroDivisionError:
    print("You cannot divide by zero.")
else:
    print("The result is:", result)
finally:
    print("Execution finished.")

"""## Common Types of Exceptions in Python.

Let's take a look at some of the most common types of exceptions in Python:

1. SyntaxError: This exception is raised when the interpreter encounters a syntax error in the code. It could be due to a misspelled keyword, a missing colon, or an unbalanced parenthesis.

2. TypeError: This exception occurs when an operation or function is applied to an object of the wrong type. For example, if you try to add a string to an integer, Python will raise a TypeError.

3. NameError: This exception is raised when you try to access a variable or function that hasn't been defined yet.

4. ZeroDivisionError: This exception occurs when you try to divide a number by zero.

These are just a few examples of the types of exceptions you might encounter while coding in Python. Exception handling provides benefits like easy error detection and debugging, maintaining code readability, and focusing on program logic. It helps in writing cleaner and more maintainable code.

"""